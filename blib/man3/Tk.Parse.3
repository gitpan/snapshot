.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Parse 3 "Tk402.001" "18/Mar/97" "perl/Tk Documentation"
.IX Title "Parse 3"
.UC
.IX Name "Pod::Parse - Parse perl's pod files."
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Pod::Parse \- Parse perl's pod files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\fBTHIS TK SNAPSHOT SHOULD BE REPLACED BY A CPAN MODULE\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A module designed to simplify the job of parsing and formatting ``pods'\*(R', the
documentation format used by perl5. This consists of several different
functions to present and modify predigested pod files.
.SH "GUESSES"
.IX Header "GUESSES"
This is a work in progress, so I may have some stuff wrong, perhaps badly.
Some of my more reaching guesses:
.Ip "\(bu" 4
.IX Item "\(bu"
An =index paragraph should be split into lines, and each line placed inside
an `X\*(R' formatting command which is then preprended to the next paragraph,
like this:
.Sp
.Vb 8
\&  =index foo
\&  foo2
\&  foo3
\&  foo2!subfoo
\&  
\&  Foo!
\& 
\&Will become:
.Ve
.Vb 1
\&  X<foo>X<foo2>X<foo3>X<foo2!subfoo>Foo!
.Ve
.Ip "\(bu" 4
.IX Item "\(bu"
A related change: that an `X\*(R' command is to be used for indexing data. This
implies that all formatters need to at least ignore the `X\*(R' command.
.Ip "\(bu" 4
.IX Item "\(bu"
Inside an =command, no special significance is to be placed on the first line
of the argument. Thus the following two lines should be parsed identically:
.Sp
.Vb 4
\& =item 1. ABC
\& 
\& =item 1.
\& ABC
.Ve
Note that neither of these are identical to this:
.Sp
.Vb 3
\& =item 1.
\& 
\& ABC
.Ve
which puts the \*(L"\s-1ABC\s0\*(R" in a separate paragraph.
.Ip "\(bu" 4
.IX Item "\(bu"
I actually violate this rule twice: in parsing =index commands, and in
passing through the =pragma commands. I hope this make sense.
.Ip "\(bu" 4
.IX Item "\(bu"
I added the =comment command, which simply ignores the next paragraph
.Ip "\(bu" 4
.IX Item "\(bu"
I also added =pragma, which also ignores the next paragraph, but this time
it gives the formatter a chance at doing something sinister with it.
.SH "POD CONVENTIONS"
.IX Header "POD CONVENTIONS"
This module has two goals: first, to simplify the usage of the pod format,
and secondly the codification of the pod format. While perlpod contains some
information, it hardly gives the entire story. Here I present \*(L"the rules\*(R",
or at least the rules as far as I've managed to work them out.
.Ip "Paragraphs: The basic element" 4
.IX Item "Paragraphs: The basic element"
The fundamental \*(L"atom\*(R" of a pod file is the paragraph, where a paragraph is
defined as the text up to the next completely blank line (\*(R"\en\en"). Any pod
parser will read in paragraphs sequentially, deciding what do to with each
based solely on the current state and on the text at the _beginning_ of the
paragraph.
.Ip "Commands: The method of communication" 4
.IX Item "Commands: The method of communication"
A paragraph that starts with the `=\*(R' symbol is assumed to be a special command.
All of the alphanumeric characters directly after the `=\*(R' are assumed to be
part of the name of the command, up to the first whitespace. Anything past that
whitespace is considered \*(L"the arugment\*(R", and the argument continues up till
the end of the paragraph, regardless of newlines or other whitespace.
.Ip "Text: Commands that aren't Commands" 4
.IX Item "Text: Commands that aren't Commands"
A paragraph that doesn't start with `=\*(R' is treated as either of two types of
text. If it starts with a space or tab, it is considered a \fBverbatim\fR
paragraph, which will be printed out... verbatim. No formatting changes
whatsover may be done. (Actually, this isn't quite true, but I'll get back to
that at a later date.)
.Sp
A paragraph that doesn't start with whitespace or `=\*(R' is assumed to consist of
formmated text that can be molded as the formatter sees fit. Reformatting to
fit margins, whatever, it's fair game. These paragraphs also can contain a
number of different formatting codes, which verbatim paragraphs can't. These
formatting codes are covered later.
.Ip "=cut: The uncommand" 4
.IX Item "=cut: The uncommand"
There is one command that needs special mention: =cut. Anything after a
paragraph starting with =cut is simply ignored by the formatter. In
addition, any text \fBbefore\fR a valid command is equally ignored. Any valid
`=\*(R' command will reenable formating. This fact is used to great benefit by
Perl, which is glad to ignore anything between an `=\*(R' command and `=cut\*(R', so
you can embed a pod document right inside a perl program, and neither will
bother the other.
.Ip "Reference to paragraph commands" 4
.IX Item "Reference to paragraph commands"
.Ip "=cut" 8
.IX Item "=cut"
Ignore anything till the next paragraph starting with `=\*(R'.
.Ip "=head1" 8
.IX Item "=head1"
A top-level heading. Anything after the command (either on the same line or 
on further lines) is included in the heading, up until the end of the paragraph.
.Ip "=head2" 8
.IX Item "=head2"
Secondary heading. Same as =head1, but different. No, there isn't a head3,
head4, etc.
.Ip "=over [N]" 8
.IX Item "=over [N]"
Start a list. The \f(CWN\fR is the number of characters to indent by. Not all
formatters will listen to this, though. A good number to use is 4.
.Sp
While =over sounds like it should just be indentation, it's more complex then
that. It actually starts a nested environment, specifically for the use of
=item's. As this command recurses properly, you can use more then one, you
just have to make sure they are closed off properly by =back commands.
.Ip "=back" 8
.IX Item "=back"
Ends the last =over block. Resets the indentation to whatever it was
previously. Closes off the list of =item's.
.Ip "=item" 8
.IX Item "=item"
The point behind =over and =back. This command should only be used between
them. The argument supplied should be consistent (within a list) to one of 
three types: enumeration, itemization, or description. To exemplify:
.Sp
An itemized list
.Sp
.Vb 13
\&  =over 4
\&  
\&  =item *
\&  
\&  A bulleted item
\&  
\&  =item *
\&  
\&  Another bulleted item
\& 
\&  =back
\&  
\&An enumerated list
.Ve
.Vb 13
\&  =over 4
\&  
\&  =item 1.
\&  
\&  First item.
\&  
\&  =item 2.
\&  
\&  Second item.
\&  
\&  =back
\&  
\&A described list
.Ve
.Vb 15
\&  =over 4
\&  
\&  =item Item #1
\&  
\&  First item
\&  
\&  =item Item #2 (which isn't really like #1, but is the second).
\&  
\&  Second item
\&  
\&  =back  
\&  
\&  
\&If you aren't consistent about the arguments to =item, Pod::Parse will
\&complain.
.Ve
.Ip "=comment" 8
.IX Item "=comment"
Ignore this paragraph
.Ip "=pragma" 8
.IX Item "=pragma"
Ignore this paragraph, as well, unless you know what you are doing.
.Ip "=index" 8
.IX Item "=index"
Undecided at this time, but probably magic involving X\&<>.
.Ip "Reference to formatting directives" 4
.IX Item "Reference to formatting directives"
.Ip "B\&<...>" 8
.IX Item "B\&<...>"
Format text inside the brackets as bold.
.Ip "I\&<...>" 8
.IX Item "I\&<...>"
Format text inside the brackets as italics.
.Ip "Z\&<>" 8
.IX Item "Z\&<>"
Replace with a zero-width character. You'll probably figure out some uses
for this.
.Ip "And yet more that I haven't described yet..." 8
.IX Item "And yet more that I haven't described yet..."
.SH "USAGE"
.IX Header "USAGE"
.Sh "Parse"
.IX Subsection "Parse"
This function takes a list of files as an argument. If no argument is given,
it defaults to the contents of \f(CW@ARGV\fR. Parse then reads through each file and
returns the data as a list. Each element of this list will be a nested list
containing data from a paragraph of the pod file. Elements pertaining to
\*(L"=over\*(R" paragraphs will themselves contain the nested entries for all of the
paragraphs within that list. Thus, it's easier to parse the output of Parse
using a recursive parses. (Um, did that parse?)
.PP
It is \fIhighly\fR recommended that you use the output of Simplify, not Parse,
as it's simpler.
.PP
The output will consist of a list, where each element in the list matches
one of these prototypes:
.Ip "[0,0,0,0,$filename]" 4
.IX Item "[0,0,0,0,$filename]"
This is produced at the beginning of each file parsed, where \f(CW$filename\fR is
the name of that file.
.Ip "[\-1,0,0,0,$filename]" 4
.IX Item "[\-1,0,0,0,$filename]"
End of same.
.Ip "[1,$line,$pos,0,$verbatim]" 4
.IX Item "[1,$line,$pos,0,$verbatim]"
This is produced for each paragraph of verbatim text. \f(CW$verbatim\fR is the text, 
\f(CW$line\fR is the line offset of the paragraph within the file, and \f(CW$pos\fR is the
byte offset. (In all of the following elements, \f(CW$pos\fR and \f(CW$line\fR have identical
meanings, so I'll skip explaining them each time.)
.Ip "[2,$line,$pos,$level,$heading]" 4
.IX Item "[2,$line,$pos,$level,$heading]"
Producded by a =head1 or =head2 command. \f(CW$level\fR is either 1 or 2, and \f(CW$heading\fR
is the argument.
.Ip "[3,$line,$pos,0,$item]" 4
.IX Item "[3,$line,$pos,0,$item]"
$item is the argument from an =item paragraph.
.Ip "[4,$line,$pos,0,$index]" 4
.IX Item "[4,$line,$pos,0,$index]"
$index is the argument from an =index paragraph.
.Ip "[6,$line,$pos,0,$text]" 4
.IX Item "[6,$line,$pos,0,$text]"
Normal formatted text paragraph. \f(CW$text\fR is the text.
.Ip "[7,$line,$pos,0,$pragma]" 4
.IX Item "[7,$line,$pos,0,$pragma]"
$pragma is the argument from a =pragma paragraph.
.Ip "[8,$line,$pos,$indentation,$type,...]" 4
.IX Item "[8,$line,$pos,$indentation,$type,...]"
This item is produced for each matching =over/=back pair. \f(CW$indentation\fR is
the argument to =over, \f(CW$type\fR is 1 if the embedded =item's are bulleted, 2 if
they are enumerated, 3 if they are text, and 0 if there are no items.
.Sp
The \*(L"...\*(R" indicates an unlimited number of further elements which are
themselves nested arrays in exactly the format being described. In other
words, a list item includes all the paragraphs inside the list inside
itself. (Clear? No? Nevermind.)
.Ip "[9,$line,$pos,0,$cut]" 4
.IX Item "[9,$line,$pos,0,$cut]"
$cut contains the text from a =cut paragraph. You shouldn't need to use
this, but I _suppose_ it might be necessary to do special breaks on a cut. I
doubt it though. This one is \*(L"depreciated\*(R", as Larry put it. Or perhaps
disappreciated.
.Sh "Simplify"
.IX Subsection "Simplify"
This procedure takes as it's input the convoluted output from \fIParse()\fR, and
outputs a much simpler array consisting of pairs of commands and arguments,
designed to be easy (easier?) to parse in your pod formatting code.
.PP
It is used very simply by saying something like:
.PP
.Vb 5
\& @Pod = Simplify(Parse());
\& 
\& while($cmd = shift @Pod) { $arg = shift @Pod;
\&        #...
\& }
.Ve
Where #... is the code that responds to any of the commands from the
following list. Note that you are welcome to ignore any of the commands that
you want to. Many contain duplicate information, or at least information
that will go unused. A formatted based on this data can be quite simple
indeed. (See pod2text for entirely too simple an example.)
.Sh "Reference to Simplify commands"
.IX Subsection "Reference to Simplify commands"
.Ip "\*(N"filename\*(T"" 4
.IX Item "\*(N"filename\*(T""
The argument contains the name of the pod file that is being parsed. These
will be present at the start of each file. You should open an output file,
output headers, etc., based on this, and not when you start parsing.
.Ip "\*(N"endfile\*(T"" 4
.IX Item "\*(N"endfile\*(T""
The end of the file. Each file will be ended before the next one begins, and
after all files are done with. You can do end processing here. The argument
is the same name as in \*(L"filename\*(R".
.Ip "\*(N"setline\*(T"" 4
.IX Item "\*(N"setline\*(T""
This gives you a chance to record the \*(L"current\*(R" input line, probably for
debugging purposes. In this case, \*(L"current\*(R" means that the next command you
see that was derived from an input paragraph will have start at the
arguments line in the file.
.Ip "\*(N"setloc\*(T"" 4
.IX Item "\*(N"setloc\*(T""
Same as setline, but the byte offset in the input, instead of the line offset.
.Ip "\*(N"pragma\*(T"" 4
.IX Item "\*(N"pragma\*(T""
The argument contains the text of a pragma command.
.Ip "\*(N"text\*(T"" 4
.IX Item "\*(N"text\*(T""
The argument contains a paragraph of formatted text.
.Ip "\*(N"verbatim\*(T"" 4
.IX Item "\*(N"verbatim\*(T""
The argument contains a paragraph of verbatim text.
.Ip "\*(N"cut\*(T"" 4
.IX Item "\*(N"cut\*(T""
A =cut command was hit. You shouldn't really need to listen for this one.
.Ip "\*(N"index\*(T"" 4
.IX Item "\*(N"index\*(T""
The argument contains an =index paragraph. (Note: Current =index commands are
not fed through, but turned into X\&<> commands.)
.Ip "\*(N"head1\*(T"" 4
.IX Item "\*(N"head1\*(T""
.Ip "\*(N"head2\*(T"" 4
.IX Item "\*(N"head2\*(T""
The argument contains the argument from a header command.
.Ip "\*(N"setindent\*(T"" 4
.IX Item "\*(N"setindent\*(T""
If you are tracking indentation, use the argument to set the indentation level.
.Ip "\*(N"listbegin\*(T"" 4
.IX Item "\*(N"listbegin\*(T""
Start a list environment. The argument is the type of list (1,2,3 or 0).
.Ip "\*(N"listend\*(T"" 4
.IX Item "\*(N"listend\*(T""
Ends a list environment. Same argument as listbegin.
.Ip "\*(N"listtype\*(T"" 4
.IX Item "\*(N"listtype\*(T""
The argument is the type of list. You can just record the argument when you
see one of these, instead of paying attention to listbegin & listend.
.Ip "\*(N"over\*(T"" 4
.IX Item "\*(N"over\*(T""
The argument is the indentation. It's probably better to listen to the
\*(L"list...\*(R" commands.
.Ip "\*(N"back\*(T"" 4
.IX Item "\*(N"back\*(T""
Ends an \*(L"over\*(R" list. The argument is the original indentation.
.Ip "\*(N"item\*(T"" 4
.IX Item "\*(N"item\*(T""
The argument is the text of the =item command.
.PP
Note that all of these various commands you've seen are syncronized properly
so you don't have to pay attention to all at once, but they are all output
for your benefit. Consider the following example:
.PP
.Vb 14
\& listtype 2
\& listbegin 2
\& setindent 4
\& over 4
\& item 1.
\& text Item #1
\& item 2.
\& text Item #2
\& setindent 0
\& listend 2
\& back 0
\& listtype 0
\& 
\&=head2 Normalize
.Ve
This command is normally invoked by Parse, so you shouldn't need to deal
with it. It just cleans up text a little, turning spare \*(L'<\*(R', \*(L'>\*(R', and \*(L'&\*(R'
characters into \s-1HTML\s0 escapes (<, etc.) as well as generating warnings for
some pod formatting mistakes.
.Sh "Normalize2"
.IX Subsection "Normalize2"
A little more aggresive formating based on heuristics. Not applied by
default, as it might confuse your own heuristics.
.Sh "\f(CW%Escapes\fR"
.IX Subsection "\f(CW%Escapes\fR"
This hash is exported from Pod::Parse, and contains default \s-1ASCII\s0
translations for some common \s-1HTML\s0 escape sequences. You might like to use this
as a basis for an \f(CW%HTML_Escapes\fR array in your own formatter.

.rn }` ''
