.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH INTERNALS 1 "Tk402.001" "18/Mar/97" "perl/Tk Documentation"
.IX Title "INTERNALS 1"
.UC
.IX Name "CallingTk - what is Perl Tk interface doing when you call Tk functions."
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
CallingTk \-  what is Perl Tk interface doing when you call Tk functions.
.PP
This information is worse than useless for \f(CWperlTk\fR users, but can of
some help for people interested in using modified Tk source with
\f(CWperlTk\fR.
.PP
\fIThis document is under construction. The information is believed to
be pertinent to the version of\fR \f(CWportableTk\fR \fIavailable when it was
created. All the details are subject to change.\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Ip "PreCompiling" 5
.IX Item "PreCompiling"
Before the actual compilation stage a script scans the source
and extracts the subcommands of different commands. This information
resides in the file \f(CWpTk/Methods.def\fR.
.Ip "Compilation" 5
.IX Item "Compilation"
During compilation the above file is included in the source of booting
routine of dynamic (or static) library. More precisely, the booting
code of module \f(CWTk\fR calls the subroutine \fIBoot_Glue()\fR from the module
\f(CWtkGlue.c\fR, and this subroutine includes the file (with appropriate
macro definitions).
.Ip "Inside \f(CWuse Tk;\fR" 5
.IX Item "Inside \f(CWuse Tk;\fR"
The module bootstraps the C code, then loads the Perl libraries. The
heart of the Perl code is contained in the \f(CWTk::Widget\fR library, all the
widgets inherit from this module. Code for toplevels is loaded from
\f(CWTk::MainWindow\fR. 
.Sp
During bootstrap of the C glue code the \f(CWXevent::?\fR codes and a
handful of \f(CWTk::Widget\fR and \f(CWTk::Image\fR routines are defined. (Much
more XSUBs are created from \f(CWTk.xs\fR code.) The widget subcommands are
glued to Perl basing on the list included from \f(CWpTk/Methods.def\fR. In
fact all the subcommands are glued to XSUBs that are related to the
same C subroutine \fIXStoWidget()\fR, but have different data parts.
.Sp
During the Perl code bootstrap the method \f(CWTk::Widget::import\fR is
called. This call requires all the code from particular widget
packages.
.Sp
Code from the widget packages calls an obscure command like
.Sp
.Vb 1
\&  (bless \e"Text")->WidgetClass;
.Ve
This command (actually \fITk::Widget::WidgetClass()\fR) creates three
routines: \fITk::Widget::Text()\fR, \fITk::Widget::isText()\fR, and
\fITk::Text::isText()\fR. The first one is basically \f(CWnew\fR of \f(CWTk::Text\fR,
the other two return constants. It also puts the class into
depository.
.Ip "Inside \f(CW$top = MainWindow->new;\fR" 5
.IX Item "Inside \f(CW$top = MainWindow->new;\fR"
This is quite intuitive. This call goes direct to
\f(CWTk::MainWindow::new\fR, that calls \s-1XSUB\s0
\f(CWTk::MainWindow::CreateMainWindow\fR, that calls C subroutine
\fITk_CreateMainWindow()\fR. It is a \f(CWTk\fR subroutine, so here black magic
ends (almost).
.Sp
The only remaining black magic is that the \f(CWTk\fR initialization
routine creates a lot of commands, but the subroutine for creation is
usurped by \fBportableTk\fR and the commands are created in the package
\f(CWTk\fR. They are associated to XSUBs that are related to one of three C
subroutines \fIXStoSubCmd()\fR, \fIXStoBind()\fR, or \fIXStoTk()\fR, but have different
data parts.
.Sp
The result of the call is blessed into \f(CWTk::MainWindow\fR, as it should.
.Ip "Inside \f(CW$top->title('Text demo');\fR" 5
.IX Item "Inside \f(CW$top->title('Text demo');\fR"
The package \f(CWTk::Toplevel\fR defines a lot of subroutines on the fly on
some list. All the commands from the list are converted to the
corresponding subcommands of \f(CWwm\fR method of the widget. Here
subcommand is a command with some particular second argument (in this
case \f(CW"title"\fR). Recall that the first argument is \f(CW$self\fR.
.Sp
Now \f(CWTk::Toplevel\fR \f(CW@ISA\fR \f(CWTk::Widget\fR, that in turn \f(CW@ISA\fR \f(CWTk\fR. So a
call to \f(CW$top->\fIwm\fR\|('title','Text demo')\fR calls \f(CWTk::wm\fR, that is
defined during call to \fITk_CreateMainWindow()\fR. As it is described
above, the \s-1XSUB\s0 associated to \fIXStoSubCmd()\fR is called.
.Sp
This C routine is defined in \f(CWtkGlue.c\fR. It gets the data part of
\s-1XSUB\s0, creates a \f(CWSV\fR with the name of the command, and calls
\fICall_Tk()\fR with the \s-1XSUB\s0 data as the first argument, and with the name
of \s-1XSUB\s0 stuffed into the Perl stack in the place there \f(CWtk\fR expects
it. (In fact it can also reorder the arguments if it thinks it is
what you want).
.Sp
The latter procedure extracts name of \f(CWtk\fR procedure and
\f(CWclientData\fR from the first argument and makes a call, using Perl
stack as \f(CWargv\fR for the procedure. A lot of black magic is performed
afterwards to convert result of the procedure to a Perl array return.
.Ip "Inside \f(CW$text = $top->Text(background => $txtBg);\fR" 5
.IX Item "Inside \f(CW$text = $top->Text(background => $txtBg);\fR"
Above we discussed how the command \f(CWTk::Widget::Text\fR is created. The
above command calls it via inheritance. It is translated to 
.Sp
.Vb 1
\&  Tk::Text::new($top, background => $txtBg);
.Ve
The package \f(CWTk::Text\fR has no method \f(CWnew\fR, so the
\f(CWTk::Widget::new\fR is called. In turn it calls
\f(CWTk::Text->\fIDoInit\fR\|($top)\fR, that is
\f(CWTk::Widget::DoInit(Tk::Text,$top)\fR, that initializes the bindings if
necessary. Then it creates the name for the widget of the form
\&\f(CW.text0\fR, and calls \f(CW\fITk::text\fR\|('.text0', background => \f(CW$txtBg\fR)\fR
(note lowercase). The result of the call is blessed into \f(CWTk::Text\fR,
and the method \f(CWbindtags\fR for this object is called. 
.Sp
Now the only thing to discuss is who defines the methods \f(CWtext\fR and
\f(CWbindtags\fR. The answer is that they are defined in \f(CWtkWindow.c\fR,
and these commands are created in the package \f(CWTk\fR in the same sweep
that created the command \f(CWTk::wm\fR discussed above.
.Sp
So the the same C code that corresponds to the processing of
corresponding \s-1TCL\s0 commands is called here as well (this time via
\f(CWXStoTk\fR interface).
.Ip "Inside \f(CW$text->insert('insert','Hello, world!');\fR" 5
.IX Item "Inside \f(CW$text->insert('insert','Hello, world!');\fR"
As we discussed above, the subcommands of widget procedures correspond
to \s-1XSUB\s0 \f(CWXStoWidget\fR. This \s-1XSUB\s0 substitutes the first argument \f(CW$text\fR
(that is a hash reference) to an appropriate value from this hash,
adds the additional argument after the first one that contains the
name of the subcommand extracted from the data part of \s-1XSUB\s0, and calls
the corresponding Tk C subroutine via \f(CWCall_Tk\fR.
.PP
Ilya Zakharevich <ilya@math.ohio-state.edu> 

.rn }` ''
